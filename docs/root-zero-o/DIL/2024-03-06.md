### 2024-03-06
- 공부 범위 : 1.3 클래스 ~ 1.6 리액트에서 자주 사용하는 JS 문법
- 공부 시간 : 퇴근 후 21:30 ~ 23:00
> 성능을 따질 때 바벨 트랜스파일 전후 또한 고려해야 한다는 것을 알았습니다(!). 그리고 그동안 조금 헷갈렸던 이벤트 루프, 태스크 큐, 마이크로태스트 큐와 렌더링의 개념을 쉽게 떠올릴 수 있게 되었습니다.

<br/>
<br/>

## 1.3 클래스
### 클래스란?
- 특정한 형태의 객체를 반복적으로 만들기 위해 사용한다.
- 데이터나 이를 조작하는 코드를 추상화할 수 있다.
- constructor
  - 생성자. 객체를 생성하는 데 사용하는 특수한 메서드
  - 단 하나만 존재할 수 있으며, 생략할 수도 있다.
- 프로퍼티
  - 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값
  - 기본적으로는 private, 타입스크립트를 사용하면 private, protected, public 사용이 가능하다.
- getter
  - 클래스에서 값을 가져올 때 사용한다.
- setter
  - 클래스 필드에 값을 할당할 때 사용한다.
- 인스턴스 메서드
  - 클래스 내부에서 선언한 메서드
  - JS의 prototype에 선언되므로 프로토타입 메서드라 부르기도 한다.
- 정적 메서드
  - 클래스의 이름으로 호출할 수 있는 메서드
  - 정적 메서드 내부의 this가 클래스 자신을 가리키기 때문
  - 전역 유틸 함수를 정적 메서드로 많이 활용한다.
  - ```javascript
    class Car(){
      static hello(){
        console.log('hi');
      }
    }

    const myCar = new Car();
    myCar.hello() // 에러
    Car.hello() // hi
    ```

---

<br/>

## 1.4 클로저
### 클로저란?
- 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분이 클로저에 의존한다.
```javascript
function outerFunction(){
  var x = 'hello';
  function innerFunction(){
    console.log(x);
  }
  return innerFunction;
}

const innerFunction = outerFunction(); // 1) outerFunction은 innerFunction을 반환하며 종료
innerFunction() // 'hello' - 2) x가 선언된 어휘적 환경에는 x 변수 존재 -> innerFunction()은 같은 환경에서 선언되었기 때문에 x라는 변수가 존재하는 환경을 기억한다.
```
### 스코프
- 변수의 유효 범위
- 전역 스코프 : 브라우저 환경 window, Node.js 환경 global
- 함수 스코프 : 자바스크립트는 함수 레벨 스코프를 가지고 있다.

### 클로저의 활용
```javascript
  function Component(){
    const [state, setState] = useState()

    // useState 호출이 끝나도 setState는 state의 최신값을 알고 있다.
    function handleClick(){
      setState((prev) => prev + 1)
    }
  }
  ```

### 주의할 점
- 클로저는 생성될 때마다 선언적 환경을 기억 -> 추가로 비용이 발생한다.

---

<br/>

## 1.5 이벤트 루프와 비동기 통신의 이해
### 싱글 스레드 자바스크립트
- 프로세스 : 프로그램의 상태가 메모리상에서 실행되는 작업 단위
- 스레드 : 하나의 프로그램에서 여러 개의 복잡한 작업 수행 필요 -> 더 작은 실행 단위인 스레드 등장. 스레드끼리는 메모리를 공유할 수 있다.
- 싱글 스레드 언어 = 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다. 동기식으로 처리된다.

### 이벤트 루프
- JS 런타임 외부에서 비동기 실행을 돕기 위해 만들어진 장치
- 호출 스택(call stack) : JS에서 수횅해야 할 코드나 함수를 순차적으로 담아두는 스택
- 이벤트 루프(event loop)
  - 호출 스택이 비어 있는지 여부를 확인 -> 수행해야 할 코드가 있다면 JS 엔진을 이용해 실행한다.
  - 여기서 코드 실행과 호출 스택 확인은 모두 단일 스레드에서 일어난다.
- 태스크 큐(task queue)
  - 실행해야 할 태스크의 집합
  - 이벤트 루프는 태스크 큐를 한 개 이상 가지고 있다.
  - 호출 스택이 비었다면 태스크 큐에 대기중인 작업이 있는지 확인 -> 있다면 실행 가능한 가장 오래된 것부터 순차적으로 꺼내 실행한다.
- 비동기 함수는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다.
  - JS 코드 실행을 싱글 스레드에서 이루어진다.
  - 외부 Web API 등은 JS 코드 외부에서 실행되고, 콜백이 태스크 큐로 들어간다.
  - 이벤트 루프는 호출 스택이 비고, 콜백 실행 가능할 때 꺼내어 수행하는 역할을 한다.

### 태스크 큐 & 마이크로태스크 큐
- 이벤트 루프는 하나의 마이크로 태스크 큐를 가지고 있다.(예: Promise)
- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다.(예: setTimeout은 Promise보다 늦게 실행된다.)
- 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미뤄진다.
- 대표적인 작업
  - 태스크 큐 : setTimeout, setInterval, setImmediate
  - 마이크로 태스크 큐 : process.nextTick, Promiese, queueMicroTask, MutationObserver
- 렌더링
  - 마이크로 태스크 큐를 실행한 뒤 렌더링이 일어난다.
  - 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻는다.

---

<br/>
## 1.6 리액트에서 자주 사용하는 JS 문법
### 구조분해할당
- 배열 또는 객체의 값을 분해해 개별 변수에 즉시 할당하는 것
- useState : 배열 구조 분해 할당(원하는 이름으로의 변경이 자유롭다)
- 객체구조분해할당 : 트랜스파일 시 번들링 크기가 상대적으로 크다.

### 전개 구문
- 순회할 수 있는 값을 전개해 간결하게 사용할 수 있는 구문
- 객체 전개 연산자 : 트랜스파일 시 상대적으로 번들링 크기가 크다.

### 객체 초기자
```javascript
const a = 1;
const b = 2;

const obj = {
  a,
  b,
}

// {a: 1, b: 2}
```
- 트랜스파일 이후에도 큰 부담이 없다.

### Array 프로토타입 메서드 
- Array.prototype.map
  - 각 아이템 순회하며 콜백 연산 결과로 구성된 새로운 배열 리턴
- Array.prototype.filter
  - 콜백 함수에서 truthy 조건을 만족하는 새로운 배열 리턴
- Array.prototype.reduce
  - 콜백 함수, 초깃값을 인수로 받음 -> 초깃값에 따라 배열, 객체 등을 리턴
- Array.prototype.forEach
  - 배열을 순회하면서 단순히 콜백 함수 실행
  - 에러, 프로세스 종료가 아닌 이상 중간에 멈출 수 없다.







  









