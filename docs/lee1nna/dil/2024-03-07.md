# 2024-03-06 (1주차 3일)

날짜 : 2024-03-06
범위 : 70p ~ 115p

# 1.5 이벤트 루프와 비동기 통신의 이해

---

자바스크립트는 싱글 스레드에서 작동해서 한번에 하나의 작업만 동기적으로 처리 할 수 있다.

- 동기 : 직렬 방식으로 작업 처리, 매우 직관적이나 한번에 다양한 작업 처리 불가
- 비동기 : 병렬 방식으로 작업 처리, 한번에 여러 작업 실행 가능

## 1.5.1 싱글 스레드 자바스크립트

- 프로세스 : 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위
- 스레드 : 프로세스보다 더 작은 실행 단위

하나의 프로세스에서는 여러 개의 스레드를 만들 수 있고, **스레드 간에는 메모리 공유가 가능**하여 여러가지 작업을 동시에 수행 가능하다. 멀티 스레드는 내부적 처리가 복잡하다.

**자바스크립트가 싱글 스레드인 이유?**

⇒ 자바스크립트 첫선 당시엔 멀티 스레드에 대한 개념 대중화 X, 또한 브라우저에서 간단한 스크립트를 지원할 목적으로 만들어진 자바스크립트에 굳이 멀티 스레드는 필요하지 않았음.

즉, 자바스크립트의 모든 코드는 ‘동기식’ 으로 한번에 하나씩 순차적으로 처리된다.

```jsx
console.log(1)

setTimeout(() => {
    console.log(2)
}, 0)

setTimeout(() => {
    console.log(3)
}, 100)

console.log(4)
```

자바스크립트의 동기식 처리에 따르면 위 코드 실행 결과는 1 → 2 → 3 → 4가 될 것이다.
그러나 코드 실행결과는 1 → 4 → 2 → 3 이 출력 되는데, 이 비동기 코드 처리를 이해하려면
**이벤트 루프** 라는 개념을 이해해야 한다.

## 1.5.2 이벤트 루프란?

- 이벤트 루프 (eventloop) : 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

### 호출 스택과 이벤트 루프

- 호출 스택 (call stack) : 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택

**이벤트 루프는 호출 스택 내부에 수행해야 할 작업이 있는지 확인**하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다. 
’**코드를 실행하는 것’ 과 ‘호출 스택이 비어 있는지 확인하는 것’ 모두 단일 스레드**에서 일어나므로
두 작업은 동시에 일어날 수 없고 **순차적으로 일어난다**.

```jsx
function bar() {
    console.log('bar')
}

function baz() {
    console.log('baz')
}

function foo() {
    console.log('foo')
    setTimeout(bar, 0)
    baz()
}
```

위 코드를 보면, setTimeout(() ⇒ {}, 0)이 정확하게 0초 뒤에 실행된다는 것을 보장하지 못한다는 걸 알 수 있다.

여기서 태스크 큐라는 새로운 개념이 나타난다.

- 태스크 큐 : 실행해야 할 태스크의 집합을 의미, 이름과 다르게 queue 가 아닌 set 형태를 띔

**태스크 큐에서 의미하는 ‘실행해야 할 태스크’**라는 것은 **비동기 함수의 콜백 함수나 이벤트 핸들러** 등을 의미한다.

즉, **이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할**이다. **호출 스택이 비어 있다면** 태스크 큐에 대기 중인 작업이 있는지 확인하고, 이 작업을 **실행 가능한 오래된 것부터 순차적으로 꺼내와서 실행**한다.

책을 읽으면서 잘 이해가 안되었던 부분이 있다.

> 태스크 큐는 자료구조의 큐가 아닌 set 형태를 띠고 있는데, 그 이유는 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이라고 한다.
자료구조 큐는 무조건 앞에 있는 것을 FIFO 형식으로 꺼내와야 하지만 태스크 큐는 그렇지 않다.
> 

⇒ 이 문장을 보고 실행 가능한 가장 오래된 태스크를 꺼내오는 것이 FIFO 형식이라는 생각이 들어 잘 이해가 되지 않아서 검색을 통해 알아본 결과는 다음과 같았다.
**”태스크 큐는 자료구조의 큐가 아닌 set 형태를 띠고 있다”는 표현은 태스크 큐에서 특정 작업을 선택해 실행하는 방식이 항상 FIFO가 아닐수도 있다는 것을 의미하고
”실행 가능한 가장 오래된 것” 이라는 표현은 이벤트 루프가 작업을 처리 할 때 일반적으로 태스크 큐의 작업 중 가장 오래된 것부터 시작한다는 것을 의미한다.**

그럼 비동기 함수는 누가 수행할까?

n초 뒤 setTimeout을 요청하는 작업, fetch를 기반으로 실행되는 네트워크 요청 등의 **비동기 작업은** 모두 자바스크립트 코드가 동기식으로 실행되는 **메인 스레드가 아닌 태스트 큐가 할당되는 별도의 스레드에서 수행**된다. 이건 **브라우저나 node.js의 역할**이다.
**즉, 자바스크립트 코드 실행은 싱글 스레드이지만, 외부 Web API 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어간다.**

## 1.5.3 태스크 큐와 마이크로 태스크 큐

- 마이크로 태스크 큐 : 기존 태스크 큐보다 우선권을 갖는 태스크 집합

마이크로 태스크 큐는 대표적으로 Promise가 있다.
즉, setTimeout, setInterval은 Promise보다 늦게 실행된다.

```jsx
function foo() {
    console.log('foo')
}

function bar() {
    console.log('bar')
}

function baz() {
    console.log('baz')
}

setTimeout(foo, 0)

Promise.resolve().then(bar).then(baz)
```

위 코드를 실행하면 bar, baz, foo 순으로 실행된다.
실행 결과만 봐도 Promise가 우선권이 있음을 알 수 있다.

각 태스크에 들어가는 대표적인 작업은 다음과 같다.

- 태스크 큐 : setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐 : process.nextTick, Promises, queueMicroTask, MutationObserver

그럼 렌더링은 태스크일까 마이크로 태스크 큐일까?
렌더링은 마이크로 태스크 큐와 태스크 사이에 일어난다.

**마이크로 태스크 큐 → 렌더링 → 태스크 큐** 

마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링 할 기회를 얻게된다.

### 정리

---

- 자바스크립트는 싱글 스레드 언어라 동기적으로 실행된다.
- 자바스크립트의 비동기 작업은 별도의 스레드에서 실행되고 이 작업을 수행하는데 이벤트 루프, 태스크 큐, 마이크로 태스크 큐, 브라우저/Node.js API 등이 적절한 생태계를 이루고 있다.
- 이벤트 루프는 호출 스택과 태스크 큐를 반복적으로 확인하는 역할을 한다. (실행은 엔진이)
- 태스크 큐는 실행 해야 할 태스크의 집합이며, 마이크로 태스크 큐는 우선순위를 갖는 태스크의 집합이다.
- 렌더링은 마이크로 태스크 큐와 태스크 큐 사이에 일어난다.